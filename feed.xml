<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://kha-dinh.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://kha-dinh.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2024-12-31T08:57:01+00:00</updated><id>https://kha-dinh.github.io/feed.xml</id><title type="html">blank</title><subtitle>Kha Dinh&apos;s personal website</subtitle><entry><title type="html">Intel SGX Software Stack Demystified</title><link href="https://kha-dinh.github.io/blog/2024/sgx/" rel="alternate" type="text/html" title="Intel SGX Software Stack Demystified"/><published>2024-12-26T14:22:00+00:00</published><updated>2024-12-26T14:22:00+00:00</updated><id>https://kha-dinh.github.io/blog/2024/sgx</id><content type="html" xml:base="https://kha-dinh.github.io/blog/2024/sgx/"><![CDATA[<p>The software stack for developing and launching Intel SGX enclaves is such a mess. Parts of this is due to confusing naming, and lack of centralized documentations. This post the process of me trying make sense of it from a developer point of view.</p> <h2 id="the-software-stack">The software stack</h2> <p>There are awfully lots of moving parts involved in launching an SGX enclave.</p> <ul> <li>The <strong>SGX Driver</strong> allows interaction with SGX hardware components. The driver uses privileged instruction for enclave management (e.g., <code class="language-plaintext highlighter-rouge">ECREATE</code>, <code class="language-plaintext highlighter-rouge">EADD</code>, <code class="language-plaintext highlighter-rouge">EEXTEND</code>). Three endpoints are exposed to the userspace, which are communicated with through IOCTL APIs. <ul> <li><code class="language-plaintext highlighter-rouge">/dev/sgx_enclave</code> provides APIs for enclave management (<a href="https://www.kernel.org/doc/html/next/x86/sgx.html">2</a>). Some of the APIs: <ul> <li><code class="language-plaintext highlighter-rouge">SGX_IOC_ENCLAVE_CREATE</code> allocates kernel structures and invokes <code class="language-plaintext highlighter-rouge">ECREATE</code> to create an enclave.</li> <li><code class="language-plaintext highlighter-rouge">SGX_IOC_ENCLAVE_ADD_PAGES</code> add pages to uninitialized enclaves and also optionally extends its measurement.</li> <li><code class="language-plaintext highlighter-rouge">SGX_IOC_ENCLAVE_INIT</code> finalize enclave initialization.</li> </ul> </li> <li><code class="language-plaintext highlighter-rouge">/dev/sgx_provision</code>: Not sure what it does currently, probably related to secret provisioning.</li> <li><code class="language-plaintext highlighter-rouge">/dev/sgx_vepc</code> (the virtual EPC) support launching SGX enclave in guest virtual machines.</li> </ul> </li> <li><strong>Intel PSW (Platform SoftWare)</strong> is the userspace component in charge of launching enclaves and provide runtime services (key provisioning, remote attestation). <ul> <li><strong>AESM (Architectural Enclave Service Manager)</strong> service is maintained as a single binary installed at <code class="language-plaintext highlighter-rouge">opt/intel/sgxpsw/aesm/aesm_service</code> that is launched by <code class="language-plaintext highlighter-rouge">systemd</code> (<a href="https://community.intel.com/t5/Intel-Software-Guard-Extensions/what-difference-on-sgx-psw-and-sgx-sdk/m-p/1134047#M1997">1</a>).</li> <li>AESM perform the task of launching <strong>architectural enclaves</strong> (<a href="https://gramine.readthedocs.io/en/stable/sgx-intro.html">3</a>) that serve runtime services.</li> </ul> </li> <li><strong>Intel SGX SDK</strong> Contains libraries and tools that is used to develop SGX applications. <ul> <li>The library is divided into 3 functional components (<a href="https://community.intel.com/t5/Intel-Software-Guard-Extensions/what-difference-on-sgx-psw-and-sgx-sdk/m-p/1134047#M1997">1</a>): <ul> <li><strong>Trusted RunTime System (TRTS)</strong> is linked with the user enclave code</li> <li><strong>Untrusted RunTime System (URTS)</strong> is linked with the untrusted part of the application that set up the enclave application by communicating with the <code class="language-plaintext highlighter-rouge">aesm_service</code> through sockets and pipes.</li> <li>The <strong>Enclave standard library</strong> provides minimal standard C/C++ functionalities (except for I/O related tasks)</li> </ul> </li> <li>THe SDK also provides utility for building and distributing enclaves: <ul> <li><code class="language-plaintext highlighter-rouge">Edger8r</code> converts EDL files into actual interface implementation.</li> <li><code class="language-plaintext highlighter-rouge">sgx_sign</code> signs enclave binaries</li> <li><code class="language-plaintext highlighter-rouge">sgx-gdb</code> allows debugging of enclaves</li> </ul> </li> </ul> </li> <li><strong>sgx-ssl</strong> is a port of OpenSSL to be executed inside SGX enclaves, which provide cryptographic primitives to enclaves, e.g., for key signing.</li> <li><strong>DCAP (Data Center Attestation Primitives)</strong> provides two main libraries which are important in remote attestation. <ul> <li><strong>Quote generation</strong> allows an enclave to generate a <em>quote</em>, which includes the measurement (hash) of its initial state.</li> <li><strong>Quote verification</strong> enable a remove verifier to verify a generated <em>quote</em>.</li> </ul> </li> </ul> <h2 id="interactions">Interactions</h2> <p>Below are my attempts at providing an overview of how the software components interact with each other. Generally, the development stages of an enclave application can be classified into <em>build time</em> and <em>deployment time</em>.</p> <p>The diagrams contain all the components (and subcomponents) that were mentioned above. Note that this is heavily simplified, and may be also incorrect, as it reflect my current understanding.</p> <h3 id="build-time">Build time</h3> <p>The goal of building phase is to compile the source files of the enclave and the untrusted application, and an specification for the interface between them written in Enclave Definition Language (EDL). The output are (1) a signed enclave ELF and (2) the untrusted application, which is a normal ELF file.</p> <p><img src="/assets/img/sgx-build.png" alt="build" width="700"/></p> <h3 id="deployment-time">Deployment time</h3> <p>To deploy an enclave, the untrusted part of the enclave application communicate with <code class="language-plaintext highlighter-rouge">aesm_service</code> to create and initialize the enclave.</p> <p><img src="/assets/img/sgx-deployment.png" alt="build" width="700"/></p> <h2 id="distribution">Distribution</h2> <p>Intel provides a prebuilt version for most components, so the users don’t have to rebuild them from scratch. They can be accessed at <a href="https://download.01.org/intel-sgx/latest/linux-latest/">https://download.01.org/intel-sgx/latest/linux-latest/</a></p> <p>The driver for SGX is built into most modern Linux distribution (since Linux 5.11 <a href="https://gramine.readthedocs.io/en/stable/sgx-intro.html">3</a>), so manually installing them is not encouraged.</p>]]></content><author><name></name></author><category term="blog"/><category term="sgx"/><summary type="html"><![CDATA[Notes on SGX Software Stack]]></summary></entry><entry><title type="html">GitJournal: The missing piece to my note taking workflow</title><link href="https://kha-dinh.github.io/blog/2024/gitjournal/" rel="alternate" type="text/html" title="GitJournal: The missing piece to my note taking workflow"/><published>2024-12-07T14:22:00+00:00</published><updated>2024-12-07T14:22:00+00:00</updated><id>https://kha-dinh.github.io/blog/2024/gitjournal</id><content type="html" xml:base="https://kha-dinh.github.io/blog/2024/gitjournal/"><![CDATA[<h2 id="some-background">Some Background</h2> <p>I have been using <a href="https://github.com/zk-org/zk">zk</a> for taking notes in plain markdown. While it lacks features compared to the well-known Obsidian, I prefer it over tools like Obsidian for the following reasons:</p> <ul> <li> <p>Using your preferred editor is possible. I am an avid <a href="https://neovim.io/">Neovim</a> user and would prefer to do all of my writing with Vim key bindings if possible. I like it so much that I even created a <a href="https://github.com/kha-dinh/bibli-ls">language server</a> to support BibTeX citations in my notes.</p> </li> <li> <p>Terminal-first workflow. zk’s nice <a href="https://github.com/junegunn/fzf">fzf</a> integration allows me to access my notes with just a single keyboard shortcut. This enables me to avoid using a mouse in general.</p> </li> <li> <p>Lightweight design. I like that zk provides the bare minimum tools for looking up your notes and providing editor-agnostic diagnostics highlighting through its LSP protocol. This enables me to quickly set up the note-taking workflow on any new desktop.</p> </li> </ul> <p>For maintaining my notes, I have a private GitHub repo that I regularly push to. I prefer this to cloud synchronization due to its simplicity.</p> <h2 id="complaints">Complaints</h2> <p>One of the pet peeves I have with the terminal + git workflow is that it is fundamentally difficult to <strong>synchronize</strong> and <strong>access</strong> your notes on mobile devices. All available options are not ideal.</p> <p>For synchronization:</p> <ul> <li>Upload your notes to a cloud service and use <a href="https://syncthing.net/">syncthing</a> to automatically synchronize. This means you must keep your notes in two places.</li> </ul> <p>For reading/editing:</p> <ul> <li>Using a terminal emulator like <a href="https://termux.dev/en/">termux</a>. A keyboard is required which is only sometimes available on the go, and setting up is still a hassle.</li> <li>Directly accessing your notes through GitHub’s web interface. This results in a terrible editing experience.</li> </ul> <p>In contrast, Obsidian has a dedicated <a href="https://obsidian.md/mobile">mobile app</a> that streamlines the experience on both desktop and mobile phones. Obsidian users might use Obsidian’s cloud service or the Obsidian git plugin to maintain their notes.</p> <h2 id="gitjournal">GitJournal</h2> <p>Recently, I encountered the <a href="https://github.com/GitJournal/GitJournal">GitJournal</a> mobile application that solves the aforementioned issues. It simplifies notes synchronization and editing into a single mobile app:</p> <ul> <li>Markdown preview/editing support. The app prioritizes support for markdown notes in plaintext.</li> <li>Simplified git synchronization at the push of a button.</li> <li><em>Links between notes work</em>! I can just press on a link, e.g., <code class="language-plaintext highlighter-rouge">[[AkgiO4ax]]</code>, to visit the note. This is partly thanks to zk’s use of the file name (a random UUID) as notes link.</li> </ul> <p>While there are still a few minor issues, I can live with them:</p> <ul> <li>The pricing for pro features is a bit steep, so I need some time to decide if it’s worth it.</li> <li>Note UUID generation scheme doesn’t match with my zk’s note ID system. Still, I can edit them when I get to my desktop.</li> </ul> <h2 id="conclusion">Conclusion</h2> <p>GitJournal has filled a crucial gap in my note-taking system, allowing me to maintain the terminal-first, git-based workflow I love on the desktop while gaining seamless mobile access. It proves that we don’t always need to compromise between power-user preferences and mobile convenience. For those who prefer lightweight, text-based note-taking tools like zk but want better mobile integration, GitJournal offers an elegant solution that respects the simplicity and flexibility of plain markdown files while making them accessible on the go.</p>]]></content><author><name></name></author><category term="blog"/><category term="note-taking"/><summary type="html"><![CDATA[How GitJournal solves the need for accessing my zk notes on the go.]]></summary></entry></feed>